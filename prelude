#!/bin/bash

# Function to print usage information
print_usage() {
    echo "Usage: $0 [-P <relative_path>] [-F <output_filename>] [--help] [--manual]"
    echo "  -P <relative_path>    Specify a relative path to include only files below that path"
    echo "  -F <output_filename>  Specify a filename to save the prompt"
    echo "  -M <match_pattern>    Specify pattern(s) to match filenames and only include those files. Use '|' as a delimiter for multiple patterns"
    echo "  --help                Display help information"
    echo "  --manual              Display the manual"
}

# Function to print manual
print_manual() {
    echo "MANUAL"
    echo "This script generates a prompt containing the file tree and concatenated file contents of a specified directory."
    echo "The prompt can be copied to the clipboard and optionally saved to a file."
    echo
    echo "OPTIONS"
    echo "  -P <relative_path>"
    echo "      Specify a relative path to include only files below that path."
    echo "      If not specified, the script will include all files in the current directory and its subdirectories."
    echo
    echo "  -F <output_filename>"
    echo "      Specify a filename to save the generated prompt."
    echo "      If not specified, the prompt will only be copied to the clipboard."
    echo
    echo "  -M <match_pattern>"
    echo "      Specify pattern(s) to match filenames. Uses tree's pattern matching syntax."
    echo "      For multiple patterns, separate them with '|'. Use '*' for wildcards."
    echo "      The matching is case-insensitive by default."
    echo
    echo "  --help"
    echo "      Display help information."
    echo
    echo "  --manual"
    echo "      Display the manual."
    echo
    echo "EXAMPLES"
    echo "  $0"
    echo "      Generate a prompt for all files in the current directory and copy it to the clipboard."
    echo
    echo "  $0 -P src"
    echo "      Generate a prompt for all files below the specified path and copy it to the clipboard."
    echo
    echo "  $0 -F prompt.txt"
    echo "      Generate a prompt for all files in the current directory and save it to a file."
    echo
    echo "  $0 -P src -f prompt.txt"
    echo "      Generate a prompt for all files below the specified path and save it to a file."
    echo
    echo "  $0 -M \"*.txt|*.py\""
    echo "      Generate a prompt for all .txt and .py files."
    echo
    echo "  $0 -M \"test*\""
    echo "      Generate a prompt for all files starting with 'test'."
    echo
}

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to copy to clipboard
copy_to_clipboard() {
    local prompt="$1"
    if command_exists pbcopy; then	
        echo -e "$prompt" | pbcopy
    elif command_exists wl-copy; then
	echo -e "$prompt" | wl-copy
    elif command_exists xclip; then
        echo -e "$prompt" | xclip -selection clipboard
    elif command_exists xsel; then
        echo -e "$prompt" | xsel --clipboard --input
    elif command_exists clip; then
        echo -e "$prompt" | clip
    else
        echo "Error: No clipboard command found. Install pbcopy, xclip, xsel, or clip."
        exit 1
    fi
}

# Function to add patterns from a file to exclude_patterns
add_patterns_from_file() {
    local file="$1"
    if [ -f "$file" ]; then
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Remove leading and trailing whitespace
            line=$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            
            if [[ ! "$line" =~ ^#.*$ ]] && [[ -n "$line" ]]; then
                # Split the existing patterns into an array
                IFS='|' read -ra existing_patterns <<< "$exclude_patterns"
                
                # Flag to check if the exact pattern already exists
                local pattern_exists=false
                
                # Check if the exact pattern already exists
                for pattern in "${existing_patterns[@]}"; do
                    if [[ "$pattern" == "$line" ]]; then
                        pattern_exists=true
                        break
                    fi
                done
                
                # If the exact pattern doesn't exist, add it
                if ! $pattern_exists; then
                    if [[ -z "$exclude_patterns" ]]; then
                        exclude_patterns="$line"
                    else
                        exclude_patterns+="|$line"
                    fi
                fi
            fi
        done < "$file"
    fi
}
# Initialize variables
specified_path=""
output_filename=""
tree_pattern=""

# Parse command line arguments
while getopts ":P:F:M:-:" opt; do
    case ${opt} in
        P )
            specified_path=$OPTARG
            ;;
        F )
            output_filename=$OPTARG
            ;;
        M )
            tree_pattern=$OPTARG
            ;;
        - )
            case "${OPTARG}" in
                help)
                    print_usage
                    exit 0
                    ;;
                manual)
                    print_manual
                    exit 0
                    ;;
                *)
                    echo "Invalid option: --$OPTARG" 1>&2
                    print_usage
                    exit 1
                    ;;
            esac
            ;;
        \? )
            echo "Invalid option: $OPTARG" 1>&2
            print_usage
            exit 1
            ;;
        : )
            echo "Invalid option: $OPTARG requires an argument" 1>&2
            print_usage
            exit 1
            ;;
    esac
done

# Check if the specified path exists relative to the current directory
if [ -n "$specified_path" ]; then
    if [ ! -d "$specified_path" ]; then
        echo "Error: The specified path '$specified_path' does not exist or is not a directory."
        exit 1
    fi
    # Convert to absolute path for later comparison
    specified_path=$(realpath "$specified_path")
else
    specified_path=$(realpath .)
fi

# Define the patterns to exclude
exclude_patterns="prelude|.preludeignore|.gitignore"

# Call the function for .gitignore
add_patterns_from_file ".gitignore"

# Call the function for .preludeignore
add_patterns_from_file ".preludeignore"

# add "|prelude" to end of exclude_patterns
exclude_patterns+="|prelude"  # for some reason we need to add a final pattern to the end of the exclude_patterns, need to investigate why

# Get the file tree excluding specific patterns

file_tree=$(tree -fi --matchdirs --prune --ignore-case "$specified_path" ${exclude_patterns:+-I "\"$exclude_patterns\""} ${tree_pattern:+-P "$tree_pattern"})

# Initialize an empty string to hold the concatenated file contents
concatenated_files=""

# Iterate over each line in the file tree output
while IFS= read -r line; do
    # Skip directories and non-files
    if [ -f "$line" ]; then
        # Check if the file is within the specified path
        if [ -z "$specified_path" ] || [[ "$(realpath "$line")" == "$specified_path"* ]]; then
            concatenated_files+="\n\n--- File: $line ---\n\n"
            concatenated_files+="$(cat "$line")"
        fi
    fi
done <<< "$file_tree"

# Build the prompt with the file tree and concatenated file contents
prompt="File Tree:\n$file_tree\n\nConcatenated Files:\n$concatenated_files"

prompt_pretext="I want you to help me fix some issues with my code. I have attached the code and file structure."

# Add the pretext to the prompt
prompt="$prompt_pretext\n\n$prompt"

# Copy the prompt to clipboard
copy_to_clipboard "$prompt"

# Print a message to indicate completion
echo "Got prompt with file tree and concatenated file contents."
echo "Files included in the prompt are:"
echo "$file_tree"
echo "The prompt has been copied to the clipboard."

# Save the prompt to a file if the -F flag is specified
if [ -n "$output_filename" ]; then
    echo -e "$prompt" > "$output_filename"
    echo "The prompt has been saved to $output_filename."
fi
